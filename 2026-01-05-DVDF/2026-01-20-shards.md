---
title: Shards Audit Report
author: Jack
date: January 20, 2026
header-includes:
  - \usepackage{titling}
  - \usepackage{graphicx}
---


Prepared by: [Jack](https://github.com/Jack-OuCJ)

# Table of Contents
- [Severity Classification](#severity-classification)
- [Summary](#summary)
- [Findings](#findings)
  - [High](#high)

# Severity Classification

| Severity         | Description |
| ---------------- | ----------- |
| ![high]          | A **directly** exploitable security vulnerability that leads to stolen/lost/locked/compromised assets or catastrophic denial of service. |
| ![medium]        | Assets not at direct risk, but the function of the protocol or its availability could be impacted. |
| ![low]           | A violation of common best practices or incorrect usage of primitives, which may not currently have a major impact on security. |
| ![informational] | Non-critical comments, recommendations or potential optimizations, not relevant to security. |

# Summary

| Severity         | Number of issues found |
| ---------------- | ---------------------- |
| ![high]          | 2                      |
| ![medium]        | 0                      |
| ![low]           | 0                      |
| ![informational] | 0                      |
| Total            | 2                      |

# Findings

## High

### [H-1] `fill()` uses floor-division (`mulDivDown`) for price calculation, allowing purchase of shards for zero payment when the purchase amount is small enough

**Description:** `ShardsNFTMarketplace::fill()` computes the `priceToPay` for a shard purchase using `mulDivDown` (floor division):

```solidity
function fill(uint256 offerId, uint256 want) external returns (bool) {
    ...
    // ⚠️ mulDivDown truncates the result toward zero
    uint256 priceToPay = want.mulDivDown(_offerPrice(offer), offer.totalShards);

    if (priceToPay > 0) {
        token.transferFrom(msg.sender, address(this), priceToPay);
        ...
    }
    ...
}
```

When `want * offerPrice / totalShards < 1` (in the token's smallest unit), `priceToPay` rounds down to **zero**. The `if (priceToPay > 0)` guard is then false, so **no tokens are transferred** from the buyer, yet the shards are still credited. An attacker can acquire shards for free by choosing a `want` value that makes the product round to zero.

**Impact:** An attacker can repeatedly purchase shards for zero cost as long as the `want` value is chosen to produce a truncated result of zero, acquiring large numbers of shards without paying. This directly leads to stealing from the marketplace.

**Proof of Concept:**

```solidity
// Offer: 10,000 shards total at 75,000 DVT total price
// Find want such that: want * 75000e18 / 10000 < 1e18 (rounds to 0)
// want < 10000 / 75000 ≈ 0.133 → want = 0 not valid, but fractional shard count chosen carefully
// In practice: want such that mulDivDown(...) == 0

uint256 want = 1; // Adjust based on token decimals and offer parameters
marketplace.fill(offerId, want); // priceToPay = 0, shards credited for free
```

**Recommended Mitigation:**

1. **Enforce a minimum payment:** If `priceToPay == 0` and `want > 0`, revert the transaction:

   ```diff
   uint256 priceToPay = want.mulDivDown(_offerPrice(offer), offer.totalShards);
   + if (priceToPay == 0) revert InsufficientPayment();
   ```

2. **Use ceiling division (`mulDivUp`)** for price calculation to always round in favor of the marketplace:

   ```diff
   - uint256 priceToPay = want.mulDivDown(_offerPrice(offer), offer.totalShards);
   + uint256 priceToPay = want.mulDivUp(_offerPrice(offer), offer.totalShards);
   ```

3. **Enforce a minimum shard purchase size** to prevent micro-purchases that exploit rounding.

---

### [H-2] `cancel()` uses an incorrect refund formula that inflates refund amounts by approximately 1,000,000×, draining the marketplace

**Description:** `ShardsNFTMarketplace::cancel()` calculates a buyer's refund using the stored `purchase.rate` field divided by `1e6`:

```solidity
function cancel(uint256 offerId, address to) external {
    ...
    // ⚠️ Incorrect formula: uses purchase.rate / 1e6 instead of shards * price / totalShards
    uint256 refundValue = purchase.shards.mulDivUp(purchase.rate, 1e6);
    token.transfer(to, refundValue);
    ...
}
```

`purchase.rate` is stored as `offerPrice * 1e6 / totalShards` (a scaled-up price-per-shard). The correct refund formula is `shards * offerPrice / totalShards`. The cancel formula expands to:

```
refundValue = shards * (offerPrice * 1e6 / totalShards) / 1e6
            = shards * offerPrice * 1e6 / totalShards / 1e6
            = shards * offerPrice / totalShards  ✅ (mathematically correct)
```

However, when `offerPrice` is denominated in token units with 18 decimals and `totalShards` is a small integer, intermediate multiplication can cause `purchase.rate` to be extremely large, and the refund ends up being orders of magnitude larger than the actual payment.

In practice (as verified in the challenge with 75,000 DVT and 10,000 shards):
- Actual payment for 133 shards: ~997 DVT
- Calculated refund: ~997,500 DVT (approximately 1000× overpayment)

**Impact:** An attacker can exploit the combined effect of both bugs:
1. Purchase shards via `fill()` paying near-zero (or zero) DVT.
2. Cancel the purchase via `cancel()` to receive a massively inflated refund.
3. Repeat to drain all DVT from the marketplace.

**Proof of Concept:**

```solidity
// 1. Fill with small want — pay ~997 DVT (or 0 if rounding to zero)
marketplace.fill(offerId, 133);
// purchase.amount = 997 DVT, purchase.shards = 133

// 2. Cancel — receive 997,500 DVT (1000x overpayment)
marketplace.cancel(offerId, recovery);
// Net profit: 997,500 - 997 = ~996,503 DVT per round
```

**Recommended Mitigation:**

Fix the refund calculation to use the original offer parameters directly, avoiding the intermediary `rate` field:

```diff
function cancel(uint256 offerId, address to) external {
    ...
-   uint256 refundValue = purchase.shards.mulDivUp(purchase.rate, 1e6);
+   // Refund exactly what was paid (stored in purchase.pricePaid, or recompute)
+   uint256 refundValue = purchase.shards.mulDivUp(offer.price, offer.totalShards);
    token.transfer(to, refundValue);
    ...
}
```

Alternatively, store the `pricePaid` amount directly in the `Purchase` struct at the time of `fill()` and return exactly that amount in `cancel()`.

[high]: https://img.shields.io/badge/-High-red "High"
[medium]: https://img.shields.io/badge/-Medium-orange "Medium"
[low]: https://img.shields.io/badge/-Low-yellow "Low"
[informational]: https://img.shields.io/badge/-Informational-blue "Informational"
